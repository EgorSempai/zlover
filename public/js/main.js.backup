// Zloer Communication - Main Application
// Connect. Play. Zloer

// Socket Manager Class
class SocketManager {
  constructor() {
    this.socket = null;
    this.isConnected = false;
  }

  connect() {
    this.socket = io();
    this.setupEventListeners();
    return this.socket;
  }

  setupEventListeners() {
    this.socket.on('connect', () => {
      this.isConnected = true;
      console.log('Connected to server');
    });

    this.socket.on('disconnect', () => {
      this.isConnected = false;
      console.log('Disconnected from server');
      NotificationManager.show('Connection lost', 'error');
    });

    this.socket.on('kicked', () => {
      NotificationManager.show('You have been kicked from the room', 'error');
      setTimeout(() => {
        window.location.reload();
      }, 2000);
    });

    this.socket.on('force-mute', () => {
      rtcManager.muteAudio();
      NotificationManager.show('You have been muted by the host', 'info');
    });
  }

  emit(event, data) {
    if (this.socket && this.isConnected) {
      this.socket.emit(event, data);
    }
  }

  on(event, callback) {
    if (this.socket) {
      this.socket.on(event, callback);
    }
  }
}

// RTC Manager Class
class RTCManager {
  constructor() {
    this.localStream = null;
    this.peers = new Map(); // socketId -> RTCPeerConnection
    this.isAudioMuted = false;
    this.isVideoMuted = false;
    this.isScreenSharing = false;
    this.audioContext = null;
    this.analyser = null;
    this.audioVisualizer = null;
    this.activeSpeaker = null;
    this.availableDevices = { audioInputs: [], videoInputs: [] };
    this.currentSettings = {
      audioCodec: 'opus',
      videoCodec: 'vp9',
      audioBitrate: 128000,
      videoBitrate: 2000000,
      audioChannels: 2,
      sampleRate: 48000,
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true,
      stereoEnabled: true,
      dtxEnabled: false,
      selectedMicrophone: '',
      selectedCamera: '',
      videoResolution: '1280x720',
      videoFramerate: 30,
      audioVisualizerEnabled: true
    };
    
    // Enhanced WebRTC configuration with TURN servers
    this.config = {
      iceServers: [
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun.relay.metered.ca:80' },
        // Fallback TURN servers (these are free but may have limitations)
        {
          urls: 'turn:turn.relay.metered.ca:80',
          username: 'zloer-user',
          credential: 'zloer-pass'
        },
        {
          urls: 'turn:turn.relay.metered.ca:443',
          username: 'zloer-user', 
          credential: 'zloer-pass'
        },
        // Additional free STUN servers as fallback
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' }
      ],
      iceCandidatePoolSize: 10
    };
  }

  async enumerateDevices() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      
      this.availableDevices.audioInputs = devices.filter(device => device.kind === 'audioinput');
      this.availableDevices.videoInputs = devices.filter(device => device.kind === 'videoinput');
      
      console.log('Available devices:', this.availableDevices);
      return this.availableDevices;
    } catch (error) {
      console.error('Error enumerating devices:', error);
      return { audioInputs: [], videoInputs: [] };
    }
  }

  // High-quality audio constraints (camera off by default)
  getMediaConstraints() {
    const [width, height] = this.currentSettings.videoResolution.split('x').map(Number);
    
    return {
      audio: {
        deviceId: this.currentSettings.selectedMicrophone ? 
          { exact: this.currentSettings.selectedMicrophone } : undefined,
        echoCancellation: this.currentSettings.echoCancellation,
        noiseSuppression: this.currentSettings.noiseSuppression,
        autoGainControl: this.currentSettings.autoGainControl,
        sampleRate: this.currentSettings.sampleRate,
        channelCount: this.currentSettings.audioChannels,
        volume: 1.0,
        latency: 0.01
      },
      video: false // Start with camera off by default
    };
  }

  updateSettings(newSettings) {
    this.currentSettings = { ...this.currentSettings, ...newSettings };
    console.log('Settings updated:', this.currentSettings);
    
    // Save settings to localStorage
    localStorage.setItem('zloer-settings', JSON.stringify(this.currentSettings));
  }

  loadSettings() {
    try {
      const savedSettings = localStorage.getItem('zloer-settings');
      if (savedSettings) {
        this.currentSettings = { ...this.currentSettings, ...JSON.parse(savedSettings) };
        console.log('Settings loaded:', this.currentSettings);
      }
    } catch (error) {
      console.error('Error loading settings:', error);
    }
  }

  resetSettings() {
    this.currentSettings = {
      audioCodec: 'opus',
      videoCodec: 'vp9',
      audioBitrate: 128000,
      videoBitrate: 2000000,
      audioChannels: 2,
      sampleRate: 48000,
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true,
      stereoEnabled: true,
      dtxEnabled: false,
      selectedMicrophone: '',
      selectedCamera: '',
      videoResolution: '1280x720',
      videoFramerate: 30,
      audioVisualizerEnabled: true
    };
    
    localStorage.removeItem('zloer-settings');
    console.log('Settings reset to default');
  }
  async initializeMedia() {
    try {
      // Load saved settings
      this.loadSettings();
      
      // Enumerate devices first
      await this.enumerateDevices();
      
      // Start with audio only (camera off by default)
      const constraints = this.getMediaConstraints();
      this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
      
      // Initialize audio visualizer
      await this.initializeAudioVisualizer();
      
      // Add local video to UI (will show camera off emoji)
      uiManager.addLocalVideo(this.localStream);
      
      // Set initial video state
      this.isVideoMuted = true;
      uiManager.updateVideoButton(this.isVideoMuted);
      
      return true;
    } catch (error) {
      console.error('Error accessing media devices:', error);
      
      // Try with basic constraints as fallback
      try {
        this.localStream = await navigator.mediaDevices.getUserMedia({
          video: false,
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
        
        await this.initializeAudioVisualizer();
        uiManager.addLocalVideo(this.localStream);
        this.isVideoMuted = true;
        uiManager.updateVideoButton(this.isVideoMuted);
        NotificationManager.show('Using basic audio quality due to device limitations', 'warning');
        return true;
      } catch (basicError) {
        console.error('Error accessing audio:', basicError);
        NotificationManager.show('No microphone access. Please check permissions.', 'error');
        return false;
      }
    }
  }

  async switchDevice(deviceType, deviceId) {
    try {
      if (deviceType === 'microphone') {
        this.currentSettings.selectedMicrophone = deviceId;
      } else if (deviceType === 'camera') {
        this.currentSettings.selectedCamera = deviceId;
      }

      // Stop current stream
      if (this.localStream) {
        this.localStream.getTracks().forEach(track => track.stop());
      }

      // Get new stream with updated device
      const constraints = this.getMediaConstraints();
      this.localStream = await navigator.mediaDevices.getUserMedia(constraints);

      // Update local video
      const localVideo = document.getElementById('local-video');
      if (localVideo) {
        localVideo.srcObject = this.localStream;
      }

      // Reinitialize audio visualizer
      await this.initializeAudioVisualizer();

      // Update all peer connections with new stream
      this.peers.forEach(async (pc) => {
        const senders = pc.getSenders();
        const tracks = this.localStream.getTracks();

        for (const track of tracks) {
          const sender = senders.find(s => s.track && s.track.kind === track.kind);
          if (sender) {
            await sender.replaceTrack(track);
          } else {
            pc.addTrack(track, this.localStream);
          }
        }
      });

      NotificationManager.show(`${deviceType} switched successfully`, 'success');
      return true;
    } catch (error) {
      console.error(`Error switching ${deviceType}:`, error);
      NotificationManager.show(`Failed to switch ${deviceType}`, 'error');
      return false;
    }
  }

  async testDevice(deviceType, deviceId) {
    try {
      const constraints = deviceType === 'microphone' ? 
        { audio: { deviceId: { exact: deviceId } } } :
        { video: { deviceId: { exact: deviceId } } };

      const testStream = await navigator.mediaDevices.getUserMedia(constraints);
      
      // Create test video element
      const testVideo = document.createElement('video');
      testVideo.srcObject = testStream;
      testVideo.autoplay = true;
      testVideo.muted = true;
      testVideo.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        width: 200px;
        height: 150px;
        border: 2px solid var(--primary-color);
        border-radius: 8px;
        z-index: 10000;
        background: #000;
      `;

      document.body.appendChild(testVideo);

      // Remove test video after 5 seconds
      setTimeout(() => {
        testStream.getTracks().forEach(track => track.stop());
        document.body.removeChild(testVideo);
      }, 5000);

      NotificationManager.show(`Testing ${deviceType} for 5 seconds`, 'info');
      return true;
    } catch (error) {
      console.error(`Error testing ${deviceType}:`, error);
      NotificationManager.show(`Failed to test ${deviceType}`, 'error');
      return false;
    }
  }

  async initializeAudioVisualizer() {
    try {
      // Create audio context and analyser
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Resume audio context if it's suspended (required by some browsers)
      if (this.audioContext.state === 'suspended') {
        await this.audioContext.resume();
      }
      
      this.analyser = this.audioContext.createAnalyser();
      
      // Configure analyser for smooth visualization
      this.analyser.fftSize = 256;
      this.analyser.smoothingTimeConstant = 0.8;
      
      // Connect audio stream to analyser
      const audioTracks = this.localStream.getAudioTracks();
      if (audioTracks.length > 0) {
        const source = this.audioContext.createMediaStreamSource(this.localStream);
        source.connect(this.analyser);
        
        // Start visualization
        this.startAudioVisualization();
      }
    } catch (error) {
      console.error('Error initializing audio visualizer:', error);
      // Continue without visualizer if it fails
    }
  }

  startAudioVisualization() {
    const bufferLength = this.analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    
    const visualize = () => {
      if (!this.analyser) return;
      
      requestAnimationFrame(visualize);
      this.analyser.getByteFrequencyData(dataArray);
      
      // Calculate average volume
      let sum = 0;
      for (let i = 0; i < bufferLength; i++) {
        sum += dataArray[i];
      }
      const average = sum / bufferLength;
      
      // Update visualizer
      uiManager.updateAudioVisualizer(average, dataArray);
      
      // Detect active speaker
      if (average > 30) { // Threshold for speaking
        this.activeSpeaker = 'local';
        uiManager.setActiveSpeaker('local');
      }
    };
    
    visualize();
  }

  createPeerConnection(socketId) {
    const pc = new RTCPeerConnection(this.config);
    
    // Add local stream tracks with enhanced settings
    if (this.localStream) {
      this.localStream.getTracks().forEach(track => {
        const sender = pc.addTrack(track, this.localStream);
        
        // Configure audio encoding parameters for better quality
        if (track.kind === 'audio') {
          const params = sender.getParameters();
          if (params.encodings && params.encodings.length > 0) {
            params.encodings[0].maxBitrate = 128000; // 128 kbps for high-quality audio
          }
          sender.setParameters(params).catch(console.error);
        }
      });
    }

    // Handle incoming tracks
    pc.ontrack = (event) => {
      const [remoteStream] = event.streams;
      uiManager.addRemoteVideo(socketId, remoteStream);
      
      // Set up remote audio analysis for active speaker detection
      this.setupRemoteAudioAnalysis(socketId, remoteStream);
    };

    // Handle ICE candidates
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        socketManager.emit('signal', {
          to: socketId,
          signal: {
            type: 'ice-candidate',
            candidate: event.candidate
          }
        });
      }
    };

    // Handle connection state changes
    pc.onconnectionstatechange = () => {
      console.log(`Connection state with ${socketId}:`, pc.connectionState);
      
      if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
        this.removePeer(socketId);
      } else if (pc.connectionState === 'connected') {
        NotificationManager.show('Peer connected successfully', 'success');
      }
    };

    this.peers.set(socketId, pc);
    return pc;
  }

  setupRemoteAudioAnalysis(socketId, stream) {
    try {
      const audioTracks = stream.getAudioTracks();
      if (audioTracks.length > 0 && this.audioContext) {
        const source = this.audioContext.createMediaStreamSource(stream);
        const analyser = this.audioContext.createAnalyser();
        analyser.fftSize = 256;
        analyser.smoothingTimeConstant = 0.8;
        source.connect(analyser);
        
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        const analyze = () => {
          if (!this.peers.has(socketId)) return;
          
          requestAnimationFrame(analyze);
          analyser.getByteFrequencyData(dataArray);
          
          let sum = 0;
          for (let i = 0; i < bufferLength; i++) {
            sum += dataArray[i];
          }
          const average = sum / bufferLength;
          
          // Update remote user's audio visualizer
          uiManager.updateRemoteAudioVisualizer(socketId, average, dataArray);
          
          // Detect active speaker
          if (average > 30) {
            this.activeSpeaker = socketId;
            uiManager.setActiveSpeaker(socketId);
          }
        };
        
        analyze();
      }
    } catch (error) {
      console.error('Error setting up remote audio analysis:', error);
    }
  }

  async createOffer(socketId) {
    const pc = this.createPeerConnection(socketId);
    
    try {
      const offer = await pc.createOffer({
        offerToReceiveAudio: true,
        offerToReceiveVideo: true
      });
      
      // Modify SDP for better audio and video quality
      offer.sdp = this.enhanceAudioSDP(offer.sdp);
      offer.sdp = this.enhanceVideoSDP(offer.sdp);
      
      await pc.setLocalDescription(offer);
      
      socketManager.emit('signal', {
        to: socketId,
        signal: {
          type: 'offer',
          offer: offer
        }
      });
    } catch (error) {
      console.error('Error creating offer:', error);
    }
  }

  async handleOffer(socketId, offer) {
    const pc = this.createPeerConnection(socketId);
    
    try {
      // Enhance incoming offer SDP
      offer.sdp = this.enhanceAudioSDP(offer.sdp);
      offer.sdp = this.enhanceVideoSDP(offer.sdp);
      
      await pc.setRemoteDescription(offer);
      const answer = await pc.createAnswer();
      
      // Enhance answer SDP
      answer.sdp = this.enhanceAudioSDP(answer.sdp);
      answer.sdp = this.enhanceVideoSDP(answer.sdp);
      
      await pc.setLocalDescription(answer);
      
      socketManager.emit('signal', {
        to: socketId,
        signal: {
          type: 'answer',
          answer: answer
        }
      });
    } catch (error) {
      console.error('Error handling offer:', error);
    }
  }

  enhanceAudioSDP(sdp) {
    let enhancedSDP = sdp;
    
    // Configure based on current settings
    const { audioCodec, audioBitrate, audioChannels, stereoEnabled, dtxEnabled } = this.currentSettings;
    
    if (audioCodec === 'opus') {
      // Set Opus parameters
      const opusParams = [
        `maxaveragebitrate=${audioBitrate}`,
        audioChannels === 2 && stereoEnabled ? 'stereo=1' : 'stereo=0',
        audioChannels === 2 && stereoEnabled ? 'sprop-stereo=1' : 'sprop-stereo=0',
        dtxEnabled ? 'usedtx=1' : 'usedtx=0'
      ].join(';');
      
      enhancedSDP = enhancedSDP.replace(
        /(a=fmtp:\d+ .*)/g,
        `$1;${opusParams}`
      );
      
      // Prefer Opus codec
      enhancedSDP = enhancedSDP.replace(
        /(m=audio \d+ UDP\/TLS\/RTP\/SAVPF) (\d+)/g,
        (match, prefix, codecId) => {
          const codecs = enhancedSDP.match(/a=rtpmap:(\d+) opus/);
          if (codecs) {
            const opusId = codecs[1];
            return `${prefix} ${opusId}`;
          }
          return match;
        }
      );
    } else {
      // Handle other codecs (G.722, PCMU, PCMA)
      const codecMap = {
        'g722': 'G722',
        'pcmu': 'PCMU',
        'pcma': 'PCMA'
      };
      
      const codecName = codecMap[audioCodec];
      if (codecName) {
        const codecRegex = new RegExp(`a=rtpmap:(\\d+) ${codecName}`, 'i');
        const codecs = enhancedSDP.match(codecRegex);
        if (codecs) {
          const codecId = codecs[1];
          enhancedSDP = enhancedSDP.replace(
            /(m=audio \d+ UDP\/TLS\/RTP\/SAVPF) (\d+)/g,
            `$1 ${codecId}`
          );
        }
      }
    }
    
    return enhancedSDP;
  }

  enhanceVideoSDP(sdp) {
    let enhancedSDP = sdp;
    
    const { videoCodec, videoBitrate } = this.currentSettings;
    
    // Set video bitrate
    enhancedSDP = enhancedSDP.replace(
      /(a=fmtp:\d+ .*)/g,
      `$1;x-google-max-bitrate=${Math.floor(videoBitrate / 1000)}`
    );
    
    // Prefer selected video codec
    const codecMap = {
      'vp8': 'VP8',
      'vp9': 'VP9',
      'h264': 'H264',
      'av1': 'AV1'
    };
    
    const codecName = codecMap[videoCodec];
    if (codecName) {
      const codecRegex = new RegExp(`a=rtpmap:(\\d+) ${codecName}`, 'i');
      const codecs = enhancedSDP.match(codecRegex);
      if (codecs) {
        const codecId = codecs[1];
        enhancedSDP = enhancedSDP.replace(
          /(m=video \d+ UDP\/TLS\/RTP\/SAVPF) (\d+)/g,
          `$1 ${codecId}`
        );
      }
    }
    
    return enhancedSDP;
  }

  async handleAnswer(socketId, answer) {
    const pc = this.peers.get(socketId);
    if (pc) {
      try {
        await pc.setRemoteDescription(answer);
      } catch (error) {
        console.error('Error handling answer:', error);
      }
    }
  }

  async handleIceCandidate(socketId, candidate) {
    const pc = this.peers.get(socketId);
    if (pc) {
      try {
        await pc.addIceCandidate(candidate);
      } catch (error) {
        console.error('Error adding ICE candidate:', error);
      }
    }
  }

  removePeer(socketId) {
    const pc = this.peers.get(socketId);
    if (pc) {
      pc.close();
      this.peers.delete(socketId);
    }
    uiManager.removeVideo(socketId);
    
    // Remove stats display
    const statsSection = document.getElementById(`stats-${socketId}`);
    if (statsSection) {
      statsSection.remove();
    }
  }

  toggleAudio() {
    if (this.localStream) {
      const audioTrack = this.localStream.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = !audioTrack.enabled;
        this.isAudioMuted = !audioTrack.enabled;
        uiManager.updateMuteButton(this.isAudioMuted);
        return !this.isAudioMuted;
      }
    }
    return false;
  }

  async toggleVideo() {
    if (!this.localStream) return false;
    
    const videoTrack = this.localStream.getVideoTracks()[0];
    
    if (!videoTrack) {
      // No video track exists, need to add camera
      try {
        const [width, height] = this.currentSettings.videoResolution.split('x').map(Number);
        const videoConstraints = {
          deviceId: this.currentSettings.selectedCamera ? 
            { exact: this.currentSettings.selectedCamera } : undefined,
          width: { ideal: width, max: width * 1.5 },
          height: { ideal: height, max: height * 1.5 },
          frameRate: { ideal: this.currentSettings.videoFramerate, max: this.currentSettings.videoFramerate }
        };
        
        const videoStream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints });
        const newVideoTrack = videoStream.getVideoTracks()[0];
        
        // Add video track to existing stream
        this.localStream.addTrack(newVideoTrack);
        
        // Update local video element
        const localVideo = document.getElementById('local-video');
        if (localVideo) {
          localVideo.srcObject = this.localStream;
        }
        
        // Update all peer connections
        this.peers.forEach(async (pc) => {
          pc.addTrack(newVideoTrack, this.localStream);
        });
        
        this.isVideoMuted = false;
        uiManager.updateVideoButton(this.isVideoMuted);
        uiManager.updateLocalVideoDisplay(false);
        NotificationManager.show('Camera enabled', 'success');
        return true;
        
      } catch (error) {
        console.error('Error enabling camera:', error);
        NotificationManager.show('Failed to enable camera', 'error');
        return false;
      }
    } else {
      // Video track exists, toggle it
      videoTrack.enabled = !videoTrack.enabled;
      this.isVideoMuted = !videoTrack.enabled;
      uiManager.updateVideoButton(this.isVideoMuted);
      uiManager.updateLocalVideoDisplay(this.isVideoMuted);
      return !this.isVideoMuted;
    }
  }

  muteAudio() {
    if (this.localStream) {
      const audioTrack = this.localStream.getAudioTracks()[0];
      if (audioTrack) {
        audioTrack.enabled = false;
        this.isAudioMuted = true;
        uiManager.updateMuteButton(this.isAudioMuted);
      }
    }
  }

  async shareScreen() {
    if (this.isScreenSharing) {
      // Stop screen sharing
      await this.stopScreenShare();
      return;
    }

    try {
      const screenStream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: true
      });

      // Replace video track in all peer connections
      const videoTrack = screenStream.getVideoTracks()[0];
      
      this.peers.forEach(async (pc) => {
        const sender = pc.getSenders().find(s => 
          s.track && s.track.kind === 'video'
        );
        
        if (sender) {
          await sender.replaceTrack(videoTrack);
        }
      });

      // Update local video
      const localVideo = document.querySelector('#local-video');
      if (localVideo) {
        localVideo.srcObject = screenStream;
      }

      // Handle screen share end
      videoTrack.onended = () => {
        this.stopScreenShare();
      };

      this.isScreenSharing = true;
      uiManager.updateScreenShareButton(true);
      
      // Mark local container as screen sharing for better fullscreen experience
      const localContainer = document.getElementById('local-container');
      if (localContainer) {
        localContainer.classList.add('screen-sharing');
      }
      
      NotificationManager.show('Screen sharing started - Double-click video for fullscreen', 'success');

    } catch (error) {
      console.error('Error sharing screen:', error);
      NotificationManager.show('Failed to share screen', 'error');
    }
  }

  async stopScreenShare() {
    if (!this.isScreenSharing) return;

    try {
      // Get camera stream back
      const cameraStream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true
      });

      const videoTrack = cameraStream.getVideoTracks()[0];

      // Replace screen track with camera track in all peer connections
      this.peers.forEach(async (pc) => {
        const sender = pc.getSenders().find(s => 
          s.track && s.track.kind === 'video'
        );
        
        if (sender) {
          await sender.replaceTrack(videoTrack);
        }
      });

      // Update local video
      const localVideo = document.querySelector('#local-video');
      if (localVideo) {
        localVideo.srcObject = cameraStream;
      }

      // Update local stream reference
      this.localStream = cameraStream;

      this.isScreenSharing = false;
      uiManager.updateScreenShareButton(false);
      
      // Remove screen sharing class
      const localContainer = document.getElementById('local-container');
      if (localContainer) {
        localContainer.classList.remove('screen-sharing');
      }
      
      NotificationManager.show('Screen sharing stopped', 'info');

    } catch (error) {
      console.error('Error stopping screen share:', error);
      NotificationManager.show('Failed to stop screen sharing', 'error');
    }
  }

  cleanup() {
    // Close all peer connections
    this.peers.forEach(pc => pc.close());
    this.peers.clear();

    // Stop local stream
    if (this.localStream) {
      this.localStream.getTracks().forEach(track => track.stop());
      this.localStream = null;
    }

    // Clean up audio context
    if (this.audioContext) {
      this.audioContext.close();
      this.audioContext = null;
    }

    // Reset audio visualizer
    this.analyser = null;
    this.activeSpeaker = null;
    
    // Stop stats collection
    if (this.statsInterval) {
      clearInterval(this.statsInterval);
      this.statsInterval = null;
    }
  }

  startConnectionStats() {
    if (this.statsInterval) {
      clearInterval(this.statsInterval);
    }
    
    this.statsInterval = setInterval(() => {
      this.updateConnectionStats();
      this.measureServerPing();
    }, 1000);
  }

  stopConnectionStats() {
    if (this.statsInterval) {
      clearInterval(this.statsInterval);
      this.statsInterval = null;
    }
  }

  async updateConnectionStats() {
    try {
      // Update local stream stats
      await this.updateLocalStats();
      
      // Update remote peer stats
      for (const [socketId, pc] of this.peers) {
        await this.updateRemoteStats(socketId, pc);
      }
    } catch (error) {
      console.error('Error updating connection stats:', error);
    }
  }

  async updateLocalStats() {
    if (!this.localStream) return;
    
    const videoTrack = this.localStream.getVideoTracks()[0];
    const audioTrack = this.localStream.getAudioTracks()[0];
    
    // Update video resolution and framerate
    if (videoTrack) {
      const settings = videoTrack.getSettings();
      document.getElementById('local-resolution').textContent = 
        `${settings.width || 0}x${settings.height || 0}`;
      document.getElementById('local-framerate').textContent = 
        `${settings.frameRate || 0} fps`;
    }
    
    // Get stats from first peer connection for outbound data
    const firstPeer = this.peers.values().next().value;
    if (firstPeer) {
      const stats = await firstPeer.getStats();
      
      let videoBitrate = 0;
      let audioBitrate = 0;
      let videoCodec = this.currentSettings.videoCodec.toUpperCase();
      let audioCodec = this.currentSettings.audioCodec.toUpperCase();
      
      stats.forEach(report => {
        if (report.type === 'outbound-rtp') {
          if (report.mediaType === 'video' && report.bytesSent) {
            videoBitrate = Math.round((report.bytesSent * 8) / 1000); // kbps
          } else if (report.mediaType === 'audio' && report.bytesSent) {
            audioBitrate = Math.round((report.bytesSent * 8) / 1000); // kbps
          }
        } else if (report.type === 'codec') {
          if (report.mimeType) {
            if (report.mimeType.includes('video/')) {
              videoCodec = report.mimeType.split('/')[1].toUpperCase();
            } else if (report.mimeType.includes('audio/')) {
              audioCodec = report.mimeType.split('/')[1].toUpperCase();
            }
          }
        }
      });
      
      document.getElementById('local-video-bitrate').textContent = `${videoBitrate} kbps`;
      document.getElementById('local-audio-bitrate').textContent = `${audioBitrate} kbps`;
      document.getElementById('local-video-codec').textContent = videoCodec;
      document.getElementById('local-audio-codec').textContent = audioCodec;
    }
  }

  async updateRemoteStats(socketId, pc) {
    try {
      const stats = await pc.getStats();
      
      let videoBitrate = 0;
      let audioBitrate = 0;
      let packetLoss = 0;
      let rtt = 0;
      let videoResolution = '-';
      let framerate = 0;
      let videoCodec = '-';
      let audioCodec = '-';
      
      stats.forEach(report => {
        if (report.type === 'inbound-rtp') {
          if (report.mediaType === 'video') {
            if (report.bytesReceived) {
              videoBitrate = Math.round((report.bytesReceived * 8) / 1000);
            }
            if (report.frameWidth && report.frameHeight) {
              videoResolution = `${report.frameWidth}x${report.frameHeight}`;
            }
            if (report.framesPerSecond) {
              framerate = Math.round(report.framesPerSecond);
            }
            if (report.packetsLost && report.packetsReceived) {
              packetLoss = ((report.packetsLost / (report.packetsLost + report.packetsReceived)) * 100).toFixed(1);
            }
          } else if (report.mediaType === 'audio' && report.bytesReceived) {
            audioBitrate = Math.round((report.bytesReceived * 8) / 1000);
          }
        } else if (report.type === 'candidate-pair' && report.state === 'succeeded') {
          if (report.currentRoundTripTime) {
            rtt = Math.round(report.currentRoundTripTime * 1000);
          }
        } else if (report.type === 'codec') {
          if (report.mimeType) {
            if (report.mimeType.includes('video/')) {
              videoCodec = report.mimeType.split('/')[1].toUpperCase();
            } else if (report.mimeType.includes('audio/')) {
              audioCodec = report.mimeType.split('/')[1].toUpperCase();
            }
          }
        }
      });
      
      this.updateRemoteStatsDisplay(socketId, {
        videoBitrate,
        audioBitrate,
        packetLoss,
        rtt,
        videoResolution,
        framerate,
        videoCodec,
        audioCodec
      });
      
    } catch (error) {
      console.error(`Error getting stats for ${socketId}:`, error);
    }
  }

  updateRemoteStatsDisplay(socketId, stats) {
    const container = document.getElementById('remote-stats-container');
    let statsSection = document.getElementById(`stats-${socketId}`);
    
    if (!statsSection) {
      statsSection = document.createElement('div');
      statsSection.id = `stats-${socketId}`;
      statsSection.className = 'stats-section remote-peer-stats';
      
      const userName = document.getElementById(`name-${socketId}`)?.textContent || 'Remote User';
      
      statsSection.innerHTML = `
        <h4>${userName} (${socketId.substring(0, 8)})</h4>
        <div class="stats-data">
          <div class="stat-item">
            <span class="stat-label">Video Resolution:</span>
            <span class="stat-value" id="resolution-${socketId}">-</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Frame Rate:</span>
            <span class="stat-value" id="framerate-${socketId}">-</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Video Bitrate:</span>
            <span class="stat-value" id="video-bitrate-${socketId}">-</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Audio Bitrate:</span>
            <span class="stat-value" id="audio-bitrate-${socketId}">-</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Packet Loss:</span>
            <span class="stat-value" id="packet-loss-${socketId}">-</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">RTT:</span>
            <span class="stat-value" id="rtt-${socketId}">-</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Video Codec:</span>
            <span class="stat-value" id="video-codec-${socketId}">-</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">Audio Codec:</span>
            <span class="stat-value" id="audio-codec-${socketId}">-</span>
          </div>
        </div>
      `;
      
      container.appendChild(statsSection);
    }
    
    // Update values
    document.getElementById(`resolution-${socketId}`).textContent = stats.videoResolution;
    document.getElementById(`framerate-${socketId}`).textContent = `${stats.framerate} fps`;
    
    const videoBitrateEl = document.getElementById(`video-bitrate-${socketId}`);
    videoBitrateEl.textContent = `${stats.videoBitrate} kbps`;
    videoBitrateEl.className = 'stat-value' + (stats.videoBitrate < 500 ? ' warning' : '');
    
    const audioBitrateEl = document.getElementById(`audio-bitrate-${socketId}`);
    audioBitrateEl.textContent = `${stats.audioBitrate} kbps`;
    
    const packetLossEl = document.getElementById(`packet-loss-${socketId}`);
    packetLossEl.textContent = `${stats.packetLoss}%`;
    packetLossEl.className = 'stat-value' + (stats.packetLoss > 5 ? ' error' : stats.packetLoss > 2 ? ' warning' : '');
    
    const rttEl = document.getElementById(`rtt-${socketId}`);
    rttEl.textContent = `${stats.rtt} ms`;
    rttEl.className = 'stat-value' + (stats.rtt > 200 ? ' error' : stats.rtt > 100 ? ' warning' : '');
    
    document.getElementById(`video-codec-${socketId}`).textContent = stats.videoCodec;
    document.getElementById(`audio-codec-${socketId}`).textContent = stats.audioCodec;
  }

  measureServerPing() {
    const startTime = Date.now();
    
    // Send ping to server
    socketManager.emit('ping', { timestamp: startTime });
    
    // Listen for pong response (set up once)
    if (!this.pongListenerSet) {
      socketManager.on('pong', (data) => {
        const endTime = Date.now();
        const ping = endTime - data.timestamp;
        this.updateServerPing(ping);
      });
      this.pongListenerSet = true;
    }
  }

  updateServerPing(ping) {
    const pingElement = document.getElementById('server-ping');
    if (pingElement) {
      pingElement.textContent = `${ping} ms`;
      pingElement.className = 'stat-value' + (ping > 200 ? ' error' : ping > 100 ? ' warning' : '');
    }
  }
}

// UI Manager Class
class UIManager {
  constructor() {
    this.currentTheme = 'theme-gaming';
    this.isChatOpen = false;
    this.isAdminPanelOpen = false;
    this.userCount = 0;
    this.isHost = false;
    this.roomId = '';
    this.nickname = '';
    this.layoutMode = 'grid'; // 'grid' or 'spotlight'
    this.activeSpeaker = null;
    this.pinnedUser = null;
    this.isSettingsPanelOpen = false;
    this.audioVisualizerEnabled = true;
    this.isFullscreen = false;
    this.connectionStatsEnabled = false;
    this.statsInterval = null;
  }

  init() {
    this.setupEventListeners();
    this.loadTheme();
    this.setLayoutMode('grid'); // Initialize with grid layout
    
    // Load audio visualizer setting
    const savedSettings = localStorage.getItem('zloer-settings');
    if (savedSettings) {
      const settings = JSON.parse(savedSettings);
      this.audioVisualizerEnabled = settings.audioVisualizerEnabled !== false;
    }
    
    // Add fullscreen event listeners
    document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
    document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange());
    document.addEventListener('msfullscreenchange', () => this.handleFullscreenChange());
    
    // Add global event listener for video control buttons
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('fullscreen-btn')) {
        e.stopPropagation();
        const socketId = e.target.closest('.video-container').dataset.socketId;
        this.toggleFullscreen(socketId);
      } else if (e.target.classList.contains('pin-btn')) {
        e.stopPropagation();
        const socketId = e.target.closest('.video-container').dataset.socketId;
        this.togglePin(socketId);
      }
    });
  }

  setupEventListeners() {
    // Join form
    const joinBtn = document.getElementById('join-btn');
    const nicknameInput = document.getElementById('nickname-input');
    const roomInput = document.getElementById('room-input');

    joinBtn.addEventListener('click', () => this.handleJoin());
    
    nicknameInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') this.handleJoin();
    });
    
    roomInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') this.handleJoin();
    });

    // Theme selector
    const themeSelect = document.getElementById('theme-select');
    themeSelect.addEventListener('change', (e) => {
      this.changeTheme(e.target.value);
    });

    // Layout controls
    document.getElementById('layout-grid-btn').addEventListener('click', () => {
      this.setLayoutMode('grid');
    });

    document.getElementById('layout-spotlight-btn').addEventListener('click', () => {
      this.setLayoutMode('spotlight');
    });

    document.getElementById('visualizer-toggle-btn').addEventListener('click', () => {
      this.toggleAudioVisualizer();
    });

    document.getElementById('stats-toggle-btn').addEventListener('click', () => {
      this.toggleConnectionStats();
    });

    // Controls
    document.getElementById('mute-btn').addEventListener('click', () => {
      rtcManager.toggleAudio();
    });

    document.getElementById('video-btn').addEventListener('click', () => {
      rtcManager.toggleVideo();
    });

    document.getElementById('screen-share-btn').addEventListener('click', () => {
      rtcManager.shareScreen();
    });

    document.getElementById('chat-toggle-btn').addEventListener('click', () => {
      this.toggleChat();
    });

    // Header buttons
    document.getElementById('theme-btn').addEventListener('click', () => {
      this.cycleTheme();
    });

    document.getElementById('settings-btn').addEventListener('click', () => {
      this.toggleSettingsPanel();
    });

    // Right-click on settings for admin panel (host only)
    document.getElementById('settings-btn').addEventListener('contextmenu', (e) => {
      e.preventDefault();
      if (this.isHost) {
        this.toggleAdminPanel();
      } else {
        NotificationManager.show('Only the host can access admin controls', 'info');
      }
    });

    document.getElementById('leave-btn').addEventListener('click', () => {
      this.leaveRoom();
    });

    // Copy room ID
    document.getElementById('copy-room-btn').addEventListener('click', () => {
      navigator.clipboard.writeText(this.roomId).then(() => {
        NotificationManager.show('Room ID copied to clipboard!', 'success');
      }).catch(() => {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = this.roomId;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        NotificationManager.show('Room ID copied to clipboard!', 'success');
      });
    });

    // Chat
    const chatInput = document.getElementById('chat-input');
    const sendBtn = document.getElementById('send-btn');

    sendBtn.addEventListener('click', () => this.sendMessage());
    chatInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') this.sendMessage();
    });

    document.getElementById('chat-close-btn').addEventListener('click', () => {
      this.toggleChat();
    });

    // Admin panel
    document.getElementById('admin-close-btn').addEventListener('click', () => {
      this.toggleAdminPanel();
    });

    // Settings panel
    document.getElementById('settings-close-btn').addEventListener('click', () => {
      this.toggleSettingsPanel();
    });

    // Stats panel
    document.getElementById('stats-close-btn').addEventListener('click', () => {
      this.toggleConnectionStats();
    });

    document.getElementById('apply-settings-btn').addEventListener('click', () => {
      this.applySettings();
    });

    document.getElementById('reset-settings-btn').addEventListener('click', () => {
      this.resetSettings();
    });

    document.getElementById('test-mic-btn').addEventListener('click', () => {
      const deviceId = document.getElementById('microphone-select').value;
      if (deviceId) {
        rtcManager.testDevice('microphone', deviceId);
      }
    });

    document.getElementById('test-camera-btn').addEventListener('click', () => {
      const deviceId = document.getElementById('camera-select').value;
      if (deviceId) {
        rtcManager.testDevice('camera', deviceId);
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey) {
        switch (e.key.toLowerCase()) {
          case 'm':
            e.preventDefault();
            rtcManager.toggleAudio();
            break;
          case 'v':
            e.preventDefault();
            rtcManager.toggleVideo();
            break;
          case 's':
            e.preventDefault();
            rtcManager.shareScreen();
            break;
          case 'c':
            e.preventDefault();
            this.toggleChat();
            break;
          case 'g':
            e.preventDefault();
            this.setLayoutMode('grid');
            break;
          case 'l':
            e.preventDefault();
            this.setLayoutMode('spotlight');
            break;
          case 'e':
            e.preventDefault();
            this.toggleSettingsPanel();
            break;
          case 'f':
            e.preventDefault();
            // Toggle fullscreen for active speaker or local video
            const activeContainer = document.querySelector('.video-container.active-speaker') || 
                                  document.getElementById('local-container');
            if (activeContainer) {
              const socketId = activeContainer.dataset.socketId;
              this.toggleFullscreen(socketId);
            }
            break;
          case 'a':
            e.preventDefault();
            this.toggleAudioVisualizer();
            break;
          case 'i':
            e.preventDefault();
            this.toggleConnectionStats();
            break;
        }
      }
    });
  }

  async handleJoin() {
    const nickname = document.getElementById('nickname-input').value.trim();
    const roomId = document.getElementById('room-input').value.trim() || this.generateRoomId();

    if (!nickname) {
      NotificationManager.show('Please enter a nickname', 'error');
      return;
    }

    console.log('Starting join process...', { nickname, roomId });
    this.nickname = nickname;
    this.roomId = roomId;

    // Show loading
    document.getElementById('loading-screen').style.display = 'flex';

    try {
      // Initialize media
      console.log('Initializing media...');
      const mediaInitialized = await rtcManager.initializeMedia();
      if (!mediaInitialized) {
        console.error('Media initialization failed');
        document.getElementById('loading-screen').style.display = 'none';
        return;
      }
      console.log('Media initialized successfully');

      // Connect to server
      console.log('Connecting to server...');
      socketManager.connect();
      
      // Wait a bit for connection to establish
      setTimeout(() => {
        console.log('Joining room...', { roomId, nickname });
        socketManager.emit('join-room', { roomId, nickname });
      }, 1000);

      // Hide join screen and show app
      setTimeout(() => {
        console.log('Showing main app...');
        document.getElementById('loading-screen').style.display = 'none';
        document.getElementById('join-screen').style.display = 'none';
        document.getElementById('app').classList.remove('hidden');
        
        // Update UI
        document.getElementById('room-id-display').textContent = `Room: ${roomId}`;
      }, 2000);

    } catch (error) {
      console.error('Error during join process:', error);
      NotificationManager.show(`Join failed: ${error.message}`, 'error');
      document.getElementById('loading-screen').style.display = 'none';
    }
  }

  generateRoomId() {
    return Math.random().toString(36).substring(2, 8).toUpperCase();
  }

  addLocalVideo(stream) {
    const videoGrid = document.getElementById('video-grid');
    
    const videoContainer = document.createElement('div');
    videoContainer.className = 'video-container';
    videoContainer.id = 'local-container';
    videoContainer.dataset.socketId = 'local';
    
    const video = document.createElement('video');
    video.id = 'local-video';
    video.srcObject = stream;
    video.autoplay = true;
    video.playsinline = true;
    video.muted = true; // Local video should be muted
    
    // Add double-click for fullscreen
    video.addEventListener('dblclick', () => {
      this.toggleFullscreen('local');
    });
    
    // Audio visualizer canvas
    const visualizerCanvas = document.createElement('canvas');
    visualizerCanvas.className = 'audio-visualizer';
    visualizerCanvas.id = 'local-visualizer';
    visualizerCanvas.width = 200;
    visualizerCanvas.height = 60;
    visualizerCanvas.style.display = rtcManager.currentSettings.audioVisualizerEnabled ? 'block' : 'none';
    
    const overlay = document.createElement('div');
    overlay.className = 'video-overlay';
    overlay.innerHTML = `
      <span class="user-name">${this.nickname} (You)</span>
      <div class="video-controls">
        <span class="host-badge" style="display: ${this.isHost ? 'inline' : 'none'}">ï¿½</sp<an>
        <button class="pin-btn" onclick="uiManager.togglePin('local')" title="Pin/Unpin">ðŸ“Œ</button>
        <button class="fullscreen-btn" onclick="uiManager.toggleFullscreen('local')" title="Fullscreen">â›¶</button>
      </div>
    `;
    
    videoContainer.appendChild(video);
    videoContainer.appendChild(visualizerCanvas);
    videoContainer.appendChild(overlay);
    videoGrid.appendChild(videoContainer);
    
    this.updateLayout();
  }

  addRemoteVideo(socketId, stream) {
    const videoGrid = document.getElementById('video-grid');
    
    // Remove existing video if any
    this.removeVideo(socketId);
    
    const videoContainer = document.createElement('div');
    videoContainer.className = 'video-container';
    videoContainer.id = `video-${socketId}`;
    videoContainer.dataset.socketId = socketId;
    
    const video = document.createElement('video');
    video.srcObject = stream;
    video.autoplay = true;
    video.playsinline = true;
    
    // Add double-click for fullscreen
    video.addEventListener('dblclick', () => {
      this.toggleFullscreen(socketId);
    });
    
    // Audio visualizer canvas
    const visualizerCanvas = document.createElement('canvas');
    visualizerCanvas.className = 'audio-visualizer';
    visualizerCanvas.id = `visualizer-${socketId}`;
    visualizerCanvas.width = 200;
    visualizerCanvas.height = 60;
    visualizerCanvas.style.display = rtcManager.currentSettings.audioVisualizerEnabled ? 'block' : 'none';
    
    const overlay = document.createElement('div');
    overlay.className = 'video-overlay';
    overlay.innerHTML = `
      <span class="user-name" id="name-${socketId}">User</span>
      <div class="video-controls">
        <span class="host-badge" id="host-${socketId}" style="display: none">ðŸ‘‘</span>
        <button class="pin-btn" title="Pin/Unpin">ðŸ“Œ</button>
        <button class="fullscreen-btn" title="Fullscreen">â›¶</button>
      </div>
    `;
    
    videoContainer.appendChild(video);
    videoContainer.appendChild(visualizerCanvas);
    videoContainer.appendChild(overlay);
    videoGrid.appendChild(videoContainer);
    
    this.updateLayout();
  }

  removeVideo(socketId) {
    const videoContainer = document.getElementById(`video-${socketId}`);
    if (videoContainer) {
      videoContainer.remove();
      this.updateLayout();
    }
  }

  setLayoutMode(mode) {
    this.layoutMode = mode;
    
    // Update button states
    document.getElementById('layout-grid-btn').classList.toggle('active', mode === 'grid');
    document.getElementById('layout-spotlight-btn').classList.toggle('active', mode === 'spotlight');
    
    this.updateLayout();
    NotificationManager.show(`Switched to ${mode} view`, 'info');
  }

  updateLayout() {
    const videoGrid = document.getElementById('video-grid');
    const containers = videoGrid.querySelectorAll('.video-container');
    
    // Remove existing layout classes
    videoGrid.classList.remove('grid-layout', 'spotlight-layout');
    containers.forEach(container => {
      container.classList.remove('spotlight-main', 'spotlight-sidebar', 'grid-item');
    });
    
    if (this.layoutMode === 'spotlight') {
      videoGrid.classList.add('spotlight-layout');
      
      // Determine spotlight user (pinned user, active speaker, or first user)
      let spotlightUser = this.pinnedUser || this.activeSpeaker || 'local';
      
      containers.forEach(container => {
        const socketId = container.dataset.socketId;
        if (socketId === spotlightUser) {
          container.classList.add('spotlight-main');
        } else {
          container.classList.add('spotlight-sidebar');
        }
      });
    } else {
      videoGrid.classList.add('grid-layout');
      containers.forEach(container => {
        container.classList.add('grid-item');
      });
    }
  }

  togglePin(socketId) {
    if (this.pinnedUser === socketId) {
      this.pinnedUser = null;
      NotificationManager.show('User unpinned', 'info');
    } else {
      this.pinnedUser = socketId;
      const userName = socketId === 'local' ? 'You' : document.getElementById(`name-${socketId}`)?.textContent || 'User';
      NotificationManager.show(`${userName} pinned`, 'success');
    }
    
    // Update pin button states
    document.querySelectorAll('.pin-btn').forEach(btn => {
      btn.classList.remove('active');
    });
    
    if (this.pinnedUser) {
      const pinnedContainer = socketId === 'local' ? 
        document.getElementById('local-container') : 
        document.getElementById(`video-${this.pinnedUser}`);
      
      if (pinnedContainer) {
        pinnedContainer.querySelector('.pin-btn').classList.add('active');
      }
    }
    
    this.updateLayout();
  }

  setActiveSpeaker(socketId) {
    // Remove previous active speaker indicator
    document.querySelectorAll('.video-container').forEach(container => {
      container.classList.remove('active-speaker');
    });
    
    // Add active speaker indicator
    const speakerContainer = socketId === 'local' ? 
      document.getElementById('local-container') : 
      document.getElementById(`video-${socketId}`);
    
    if (speakerContainer) {
      speakerContainer.classList.add('active-speaker');
      this.activeSpeaker = socketId;
      
      // Update layout if in spotlight mode and no pinned user
      if (this.layoutMode === 'spotlight' && !this.pinnedUser) {
        this.updateLayout();
      }
    }
  }

  updateAudioVisualizer(volume, frequencyData) {
    if (!rtcManager.currentSettings.audioVisualizerEnabled) return;
    
    const canvas = document.getElementById('local-visualizer');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Draw frequency bars
    const barWidth = width / frequencyData.length * 2;
    let x = 0;
    
    for (let i = 0; i < frequencyData.length; i++) {
      const barHeight = (frequencyData[i] / 255) * height;
      
      // Create gradient
      const gradient = ctx.createLinearGradient(0, height - barHeight, 0, height);
      gradient.addColorStop(0, '#00ff88');
      gradient.addColorStop(0.5, '#ffaa00');
      gradient.addColorStop(1, '#ff4444');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(x, height - barHeight, barWidth, barHeight);
      
      x += barWidth + 1;
    }
    
    // Update microphone button glow
    this.updateMicrophoneGlow(volume);
  }

  updateRemoteAudioVisualizer(socketId, volume, frequencyData) {
    if (!rtcManager.currentSettings.audioVisualizerEnabled) return;
    
    const canvas = document.getElementById(`visualizer-${socketId}`);
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Draw frequency bars
    const barWidth = width / frequencyData.length * 2;
    let x = 0;
    
    for (let i = 0; i < frequencyData.length; i++) {
      const barHeight = (frequencyData[i] / 255) * height;
      
      // Create gradient
      const gradient = ctx.createLinearGradient(0, height - barHeight, 0, height);
      gradient.addColorStop(0, '#0088ff');
      gradient.addColorStop(0.5, '#00aaff');
      gradient.addColorStop(1, '#0066cc');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(x, height - barHeight, barWidth, barHeight);
      
      x += barWidth + 1;
    }
  }

  toggleAudioVisualizer() {
    this.audioVisualizerEnabled = !this.audioVisualizerEnabled;
    rtcManager.updateSettings({ audioVisualizerEnabled: this.audioVisualizerEnabled });
    
    // Show/hide all visualizer canvases
    const visualizers = document.querySelectorAll('.audio-visualizer');
    visualizers.forEach(canvas => {
      canvas.style.display = this.audioVisualizerEnabled ? 'block' : 'none';
    });
    
    // Update button state
    const btn = document.getElementById('visualizer-toggle-btn');
    if (btn) {
      btn.classList.toggle('active', this.audioVisualizerEnabled);
    }
    
    NotificationManager.show(
      `Audio visualizer ${this.audioVisualizerEnabled ? 'enabled' : 'disabled'}`, 
      'info'
    );
  }

  updateMicrophoneGlow(volume) {
    const muteBtn = document.getElementById('mute-btn');
    if (!muteBtn) return;
    
    // Create glow effect based on volume
    const intensity = Math.min(volume / 100, 1);
    const glowColor = this.isAudioMuted ? 'rgba(255, 68, 68, 0.5)' : `rgba(0, 255, 136, ${intensity})`;
    
    muteBtn.style.boxShadow = `0 0 ${intensity * 20}px ${glowColor}`;
  }

  updateUserName(socketId, nickname) {
    const nameElement = document.getElementById(`name-${socketId}`);
    if (nameElement) {
      nameElement.textContent = nickname;
    }
  }

  updateHostBadge(socketId, isHost) {
    const hostBadge = document.getElementById(`host-${socketId}`);
    if (hostBadge) {
      hostBadge.style.display = isHost ? 'inline' : 'none';
    }
  }

  updateUserCount(count) {
    this.userCount = count;
    document.getElementById('user-count').textContent = `${count} user${count !== 1 ? 's' : ''}`;
  }

  updateMuteButton(isMuted) {
    const btn = document.getElementById('mute-btn');
    btn.textContent = isMuted ? 'ðŸ”‡' : 'ðŸŽ¤';
    btn.className = `btn-control ${isMuted ? 'inactive' : 'active'}`;
    btn.title = `${isMuted ? 'Unmute' : 'Mute'} (Ctrl+M)`;
  }

  updateVideoButton(isOff) {
    const btn = document.getElementById('video-btn');
    btn.textContent = isOff ? 'ï¿½' : ''ðŸ“¹';
    btn.className = `btn-control ${isOff ? 'inactive' : 'active'}`;
    btn.title = `Camera ${isOff ? 'Off' : 'On'} (Ctrl+V)`;
  }

  updateLocalVideoDisplay(isOff) {
    const localVideo = document.getElementById('local-video');
    const localContainer = document.getElementById('local-container');
    
    if (isOff) {
      // Show camera off emoji
      if (!localContainer.querySelector('.camera-off-overlay')) {
        const overlay = document.createElement('div');
        overlay.className = 'camera-off-overlay';
        overlay.innerHTML = 'ðŸ“·';
        localContainer.appendChild(overlay);
      }
      if (localVideo) {
        localVideo.style.display = 'none';
      }
    } else {
      // Remove camera off emoji
      const overlay = localContainer.querySelector('.camera-off-overlay');
      if (overlay) {
        overlay.remove();
      }
      if (localVideo) {
        localVideo.style.display = 'block';
      }
    }
  }

  updateScreenShareButton(isSharing) {
    const btn = document.getElementById('screen-share-btn');
    btn.textContent = isSharing ? 'ðŸ–¥ï¸' : 'ðŸ–¥ï¸';
    btn.className = `btn-control ${isSharing ? 'active' : ''}`;
    btn.title = `${isSharing ? 'Stop' : 'Share'} Screen (Ctrl+S)`;
  }

  toggleChat() {
    const chatPanel = document.getElementById('chat-panel');
    this.isChatOpen = !this.isChatOpen;
    
    if (this.isChatOpen) {
      chatPanel.style.display = 'flex';
      document.getElementById('chat-input').focus();
    } else {
      chatPanel.style.display = 'none';
    }
    
    const btn = document.getElementById('chat-toggle-btn');
    btn.className = `btn-control ${this.isChatOpen ? 'active' : ''}`;
  }

  addChatMessage(data) {
    const messagesContainer = document.getElementById('chat-messages');
    
    const messageDiv = document.createElement('div');
    messageDiv.className = 'chat-message';
    
    const timestamp = new Date(data.timestamp).toLocaleTimeString();
    
    messageDiv.innerHTML = `
      <div class="chat-message-header">
        <span class="chat-nickname">${data.nickname}</span>
        <span class="chat-timestamp">${timestamp}</span>
      </div>
      <div class="chat-text">${this.escapeHtml(data.message)}</div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  }

  sendMessage() {
    const input = document.getElementById('chat-input');
    const message = input.value.trim();
    
    if (message) {
      socketManager.emit('chat-message', { message });
      input.value = '';
    }
  }

  toggleAdminPanel() {
    const adminPanel = document.getElementById('admin-panel');
    this.isAdminPanelOpen = !this.isAdminPanelOpen;
    
    if (this.isAdminPanelOpen) {
      adminPanel.classList.remove('hidden');
      this.updateAdminPanel();
    } else {
      adminPanel.classList.add('hidden');
    }
  }

  toggleSettingsPanel() {
    const settingsPanel = document.getElementById('settings-panel');
    this.isSettingsPanelOpen = !this.isSettingsPanelOpen;
    
    if (this.isSettingsPanelOpen) {
      settingsPanel.classList.remove('hidden');
      this.loadSettingsPanel();
    } else {
      settingsPanel.classList.add('hidden');
    }
  }

  async loadSettingsPanel() {
    // Load available devices
    const devices = await rtcManager.enumerateDevices();
    
    // Populate microphone dropdown
    const micSelect = document.getElementById('microphone-select');
    micSelect.innerHTML = '<option value="">Default</option>';
    devices.audioInputs.forEach(device => {
      const option = document.createElement('option');
      option.value = device.deviceId;
      option.textContent = device.label || `Microphone ${device.deviceId.substring(0, 8)}`;
      if (device.deviceId === rtcManager.currentSettings.selectedMicrophone) {
        option.selected = true;
      }
      micSelect.appendChild(option);
    });

    // Populate camera dropdown
    const cameraSelect = document.getElementById('camera-select');
    cameraSelect.innerHTML = '<option value="">Default</option>';
    devices.videoInputs.forEach(device => {
      const option = document.createElement('option');
      option.value = device.deviceId;
      option.textContent = device.label || `Camera ${device.deviceId.substring(0, 8)}`;
      if (device.deviceId === rtcManager.currentSettings.selectedCamera) {
        option.selected = true;
      }
      cameraSelect.appendChild(option);
    });

    // Load current settings into form
    const settings = rtcManager.currentSettings;
    document.getElementById('audio-codec-select').value = settings.audioCodec;
    document.getElementById('video-codec-select').value = settings.videoCodec;
    document.getElementById('audio-bitrate-select').value = settings.audioBitrate;
    document.getElementById('video-bitrate-select').value = settings.videoBitrate;
    document.getElementById('audio-channels-select').value = settings.audioChannels;
    document.getElementById('video-resolution-select').value = settings.videoResolution;
    document.getElementById('video-framerate-select').value = settings.videoFramerate;
    document.getElementById('sample-rate-select').value = settings.sampleRate;
    
    document.getElementById('echo-cancellation').checked = settings.echoCancellation;
    document.getElementById('noise-suppression').checked = settings.noiseSuppression;
    document.getElementById('auto-gain-control').checked = settings.autoGainControl;
    document.getElementById('stereo-enabled').checked = settings.stereoEnabled;
    document.getElementById('dtx-enabled').checked = settings.dtxEnabled;
    document.getElementById('audio-visualizer-enabled').checked = settings.audioVisualizerEnabled;
  }

  async applySettings() {
    try {
      const newSettings = {
        selectedMicrophone: document.getElementById('microphone-select').value,
        selectedCamera: document.getElementById('camera-select').value,
        audioCodec: document.getElementById('audio-codec-select').value,
        videoCodec: document.getElementById('video-codec-select').value,
        audioBitrate: parseInt(document.getElementById('audio-bitrate-select').value),
        videoBitrate: parseInt(document.getElementById('video-bitrate-select').value),
        audioChannels: parseInt(document.getElementById('audio-channels-select').value),
        videoResolution: document.getElementById('video-resolution-select').value,
        videoFramerate: parseInt(document.getElementById('video-framerate-select').value),
        sampleRate: parseInt(document.getElementById('sample-rate-select').value),
        echoCancellation: document.getElementById('echo-cancellation').checked,
        noiseSuppression: document.getElementById('noise-suppression').checked,
        autoGainControl: document.getElementById('auto-gain-control').checked,
        stereoEnabled: document.getElementById('stereo-enabled').checked,
        dtxEnabled: document.getElementById('dtx-enabled').checked,
        audioVisualizerEnabled: document.getElementById('audio-visualizer-enabled').checked
      };

      // Update settings
      rtcManager.updateSettings(newSettings);

      // Check if device change is needed
      const currentSettings = rtcManager.currentSettings;
      const deviceChanged = 
        newSettings.selectedMicrophone !== currentSettings.selectedMicrophone ||
        newSettings.selectedCamera !== currentSettings.selectedCamera;

      if (deviceChanged) {
        // Reinitialize media with new settings
        await rtcManager.initializeMedia();
        NotificationManager.show('Settings applied and devices updated', 'success');
      } else {
        NotificationManager.show('Settings applied successfully', 'success');
      }

      this.toggleSettingsPanel();
    } catch (error) {
      console.error('Error applying settings:', error);
      NotificationManager.show('Failed to apply settings', 'error');
    }
  }

  resetSettings() {
    if (confirm('Are you sure you want to reset all settings to default?')) {
      rtcManager.resetSettings();
      this.loadSettingsPanel();
      NotificationManager.show('Settings reset to default', 'info');
    }
  }

  toggleFullscreen(socketId) {
    const container = socketId === 'local' ? 
      document.getElementById('local-container') : 
      document.getElementById(`video-${socketId}`);
    
    if (!container) return;

    if (!this.isFullscreen) {
      // Enter fullscreen
      if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen();
      } else if (container.msRequestFullscreen) {
        container.msRequestFullscreen();
      }
      
      // Add fullscreen class for styling
      container.classList.add('fullscreen-active');
      this.isFullscreen = true;
      
      // Hide other UI elements
      document.getElementById('header')?.classList.add('hidden');
      document.getElementById('controls')?.classList.add('hidden');
      document.getElementById('chat-panel')?.classList.add('hidden');
      
      NotificationManager.show('Press ESC to exit fullscreen', 'info');
    } else {
      // Exit fullscreen
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
  }

  handleFullscreenChange() {
    const isCurrentlyFullscreen = !!(
      document.fullscreenElement ||
      document.webkitFullscreenElement ||
      document.msFullscreenElement
    );

    if (!isCurrentlyFullscreen && this.isFullscreen) {
      // Exited fullscreen
      this.isFullscreen = false;
      
      // Remove fullscreen class
      document.querySelectorAll('.fullscreen-active').forEach(el => {
        el.classList.remove('fullscreen-active');
      });
      
      // Show UI elements
      document.getElementById('header')?.classList.remove('hidden');
      document.getElementById('controls')?.classList.remove('hidden');
      
      NotificationManager.show('Exited fullscreen', 'info');
    }
  }

  toggleConnectionStats() {
    this.connectionStatsEnabled = !this.connectionStatsEnabled;
    const overlay = document.getElementById('connection-stats-overlay');
    const btn = document.getElementById('stats-toggle-btn');
    
    if (this.connectionStatsEnabled) {
      overlay.classList.remove('hidden');
      btn.classList.add('active');
      rtcManager.startConnectionStats();
      NotificationManager.show('Connection stats enabled', 'info');
    } else {
      overlay.classList.add('hidden');
      btn.classList.remove('active');
      rtcManager.stopConnectionStats();
      NotificationManager.show('Connection stats disabled', 'info');
    }
  }

  updateAdminPanel() {
    // This would be populated with actual user data from the server
    const adminUsers = document.getElementById('admin-users');
    adminUsers.innerHTML = '<p>Admin controls will be populated with connected users</p>';
  }

  setHost(isHost) {
    this.isHost = isHost;
    
    // Update local host badge
    const localHostBadge = document.querySelector('#local-container .host-badge');
    if (localHostBadge) {
      localHostBadge.style.display = isHost ? 'inline' : 'none';
    }
    
    // Update settings button visibility
    const settingsBtn = document.getElementById('settings-btn');
    settingsBtn.style.display = isHost ? 'block' : 'none';
  }

  changeTheme(theme) {
    document.body.className = theme;
    this.currentTheme = theme;
    localStorage.setItem('zloer-theme', theme);
  }

  cycleTheme() {
    const themes = ['theme-default', 'theme-dark', 'theme-gaming', 'theme-neon'];
    const currentIndex = themes.indexOf(this.currentTheme);
    const nextIndex = (currentIndex + 1) % themes.length;
    this.changeTheme(themes[nextIndex]);
  }

  loadTheme() {
    const savedTheme = localStorage.getItem('zloer-theme');
    if (savedTheme) {
      this.changeTheme(savedTheme);
      document.getElementById('theme-select').value = savedTheme;
    }
  }

  leaveRoom() {
    if (confirm('Are you sure you want to leave the room?')) {
      rtcManager.cleanup();
      window.location.reload();
    }
  }

  escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }
}

// Notification Manager Class
class NotificationManager {
  static show(message, type = 'info', duration = 5000) {
    const notifications = document.getElementById('notifications');
    
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    notifications.appendChild(notification);
    
    // Auto remove after duration
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, duration);
    
    // Click to dismiss
    notification.addEventListener('click', () => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    });
  }
}

// Global instances
const socketManager = new SocketManager();
const rtcManager = new RTCManager();
const uiManager = new UIManager();

// Make instances globally accessible for debugging and fixes
window.socketManager = socketManager;
window.rtcManager = rtcManager;
window.uiManager = uiManager;

// Initialize application
document.addEventListener('DOMContentLoaded', () => {
  uiManager.init();
  
  // Hide loading screen initially
  setTimeout(() => {
    document.getElementById('loading-screen').style.display = 'none';
  }, 1000);
});

// Socket event handlers - Override the connect method
socketManager.connect = function() {
  console.log('Attempting to connect to server...');
  this.socket = io();
  
  // Set up basic socket events
  this.socket.on('connect', () => {
    this.isConnected = true;
    console.log('âœ… Connected to server successfully');
    NotificationManager.show('Connected to server', 'success');
  });

  this.socket.on('disconnect', () => {
    this.isConnected = false;
    console.log('âŒ Disconnected from server');
    NotificationManager.show('Connection lost', 'error');
  });

  this.socket.on('kicked', () => {
    NotificationManager.show('You have been kicked from the room', 'error');
    setTimeout(() => {
      window.location.reload();
    }, 2000);
  });

  this.socket.on('force-mute', () => {
    rtcManager.muteAudio();
    NotificationManager.show('You have been muted by the host', 'info');
  });
  
  // WebRTC signaling
  this.socket.on('existing-users', (data) => {
    console.log('âœ… Existing users received:', data);
    uiManager.setHost(data.isHost);
    uiManager.updateUserCount(data.users.length + 1);
    
    if (data.users.length > 0) {
      NotificationManager.show(`Found ${data.users.length} user(s) in room`, 'success');
    } else {
      NotificationManager.show('You are the first user in this room', 'info');
    }
    
    // Create offers for existing users
    data.users.forEach(socketId => {
      console.log('ðŸ“ž Creating offer for:', socketId);
      rtcManager.createOffer(socketId);
    });
  });
  
  this.socket.on('user-joined', (data) => {
    console.log('ðŸ‘‹ User joined:', data);
    uiManager.updateUserCount(uiManager.userCount + 1);
    uiManager.updateUserName(data.socketId, data.nickname);
    NotificationManager.show(`${data.nickname} joined the room`, 'success');
  });
  
  this.socket.on('user-left', (data) => {
    console.log('ðŸ‘‹ User left:', data);
    rtcManager.removePeer(data.socketId);
    uiManager.updateUserCount(uiManager.userCount - 1);
  });
  
  this.socket.on('signal', async (data) => {
    console.log('ðŸ“¡ Signal received:', data.signal.type, 'from:', data.from);
    const { from, signal } = data;
    
    try {
      switch (signal.type) {
        case 'offer':
          await rtcManager.handleOffer(from, signal.offer);
          break;
        case 'answer':
          await rtcManager.handleAnswer(from, signal.answer);
          break;
        case 'ice-candidate':
          await rtcManager.handleIceCandidate(from, signal.candidate);
          break;
      }
    } catch (error) {
      console.error('âŒ Error handling signal:', error);
    }
  });
  
  this.socket.on('chat-message', (data) => {
    uiManager.addChatMessage(data);
  });
  
  this.socket.on('host-transferred', () => {
    uiManager.setHost(true);
    NotificationManager.show('You are now the host', 'success');
  });
  
  this.socket.on('new-host', (data) => {
    // Update UI to show new host
    console.log('ðŸ‘‘ New host:', data.hostId);
  });
  
  return this.socket;
};